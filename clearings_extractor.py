# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ClearingsExtractor
                                 A QGIS plugin
 Extracts power line clearings boundaries from satellite imagery
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-03
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Yana Bakhramkhan
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor, QFont
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import (QgsProcessingAlgorithm, QgsProcessingParameterRasterLayer, 
                       QgsProcessingParameterFolderDestination, QgsProcessingProvider,
                       QgsProcessingParameterString, QgsProject, QgsRasterLayer)
from qgis.utils import iface
import processing
from .extraction_algorithm import find_clearing_algorithm
import os
from osgeo import gdal
from .resources import *

class ClearingsExtractor:
    """
    A QGIS plugin for extracting power line clearings from summer and winter images.
    Attributes:
        iface (QgisInterface): The QGIS interface instance.
        plugin_dir (str): The directory where the plugin is located.
        actions (list): A list of QAction objects for the plugin.
        menu (str): The name of the plugin menu.
        first_start (bool): A flag indicating if the plugin is starting for the first time.
    Methods:
        tr(message):
            Translates a message using QCoreApplication.
        add_action(icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
            Adds an action to the plugin.
        initGui():
            Initializes the GUI for the plugin.
        unload():
            Unloads the plugin and removes its actions from the QGIS interface.
        select_file(line_edit, file_filter):
            Opens a file dialog to select a file and sets the selected file path to the given QLineEdit.
        select_directory(line_edit):
            Opens a directory dialog to select a directory and sets the selected directory path to the given QLineEdit.
        log_message(message):
            Logs a message to the plugin's log text edit with appropriate formatting based on the message content.
        run():
            Runs the plugin, initializing the dialog and connecting signals if it's the first start.
        process_images():
            Processes the summer and winter images to extract power line clearings and saves the results.
        clear_inputs():
            Clears the input fields and log messages in the plugin dialog.
    """
    def __init__(self, iface):
        """
        Initialize the ClearingsExtractor plugin.
        Args:
            iface (QgsInterface): An interface instance that will be passed to this class
                                  which provides the hook by which you can manipulate the QGIS application at run time.
        """
        
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        self.actions = []
        self.menu = self.tr(u'&Clearings Extractor')
        self.first_start = None
        self.provider = ClearingsExtractorProvider()

    def tr(self, message):
        """
        Translates a given message string to the current locale.

        Args:
            message (str): The message string to be translated.

        Returns:
            str: The translated message string.
        """
        return QCoreApplication.translate('ClearingsExtractor', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True, status_tip=None, whats_this=None, parent=None):
        """
        Adds an action to the QGIS interface with specified properties.

        Args:
            icon_path (str): The file path to the icon for the action.
            text (str): The text label for the action.
            callback (callable): The function to be called when the action is triggered.
            enabled_flag (bool, optional): If True, the action is enabled. Defaults to True.
            add_to_menu (bool, optional): If True, the action is added to the plugin menu. Defaults to True.
            add_to_toolbar (bool, optional): If True, the action is added to the toolbar. Defaults to True.
            status_tip (str, optional): The status tip for the action. Defaults to None.
            whats_this (str, optional): The "What's This?" help text for the action. Defaults to None.
            parent (QObject, optional): The parent widget for the action. Defaults to None.

        Returns:
            QAction: The created action object.
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None:
            action.setStatusTip(status_tip)
        if whats_this is not None:
            action.setWhatsThis(whats_this)
        if add_to_toolbar:
            self.iface.addToolBarIcon(action)
        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action

    def initGui(self):
        self.add_action(
            None,
            text=self.tr(u'Extract Clearings'),
            callback=self.run,
            parent=self.iface.mainWindow(),
            add_to_toolbar=False
        )
        self.first_start = True
        
        from qgis.core import QgsApplication
        QgsApplication.processingRegistry().addProvider(self.provider)

    def unload(self):
        """
        Unloads the plugin by removing its actions from the QGIS interface.
        This method performs the following actions:
        1. Iterates through the list of actions and removes each action from the plugin menu and toolbar.
        2. Removes the custom processing provider from the QGIS processing registry.
        Note:
            This method is typically called when the plugin is being disabled or uninstalled.
        """
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Clearings Extractor'), action)
            self.iface.removeToolBarIcon(action)
            
        from qgis.core import QgsApplication
        QgsApplication.processingRegistry().removeProvider(self.provider)

    def select_file(self, line_edit, file_filter):
        """
        Opens a file dialog to select a file and sets the selected file path to the provided QLineEdit widget.

        Args:
            line_edit (QLineEdit): The line edit widget where the selected file path will be set.
            file_filter (str): The file filter for the file dialog (e.g., "Text Files (*.txt);;All Files (*)").
        """
        filename, _ = QFileDialog.getOpenFileName(self.dlg, "Select File", "", file_filter)
        if filename:
            line_edit.setText(filename)

    def select_directory(self, line_edit):
        """
        Opens a dialog to select a directory and sets the selected directory path to the provided QLineEdit widget.

        Args:
            line_edit (QLineEdit): The QLineEdit widget where the selected directory path will be set.
        """
        directory = QFileDialog.getExistingDirectory(self.dlg, "Select Output Directory")
        if directory:
            line_edit.setText(directory)
            
    def log_message(self, message):
        """
        Logs a message to the logTextEdit widget with appropriate formatting based on the message content.
        Args:
            message (str): The message to be logged. If the message contains "Error", it will be displayed in red and bold.
                           If the message contains "Success", it will be displayed in green and bold. Otherwise, it will be
                           displayed in black with normal font weight.
        """
        if "Error" in message:
            self.dlg.logTextEdit.setTextColor(QColor("red"))
            self.dlg.logTextEdit.setFontWeight(QFont.Bold)
        elif "Success" in message:
            self.dlg.logTextEdit.setTextColor(QColor("green"))
            self.dlg.logTextEdit.setFontWeight(QFont.Bold)
        else:
            self.dlg.logTextEdit.setTextColor(QColor("black"))
            self.dlg.logTextEdit.setFontWeight(QFont.Normal)
        
        self.dlg.logTextEdit.append(message)
        self.dlg.logTextEdit.setTextColor(QColor("black"))
        self.dlg.logTextEdit.setFontWeight(QFont.Normal)
        QCoreApplication.processEvents()

    def run(self):
        """
        Executes the main functionality of the Clearings Extractor plugin.

        If this is the first time the plugin is being run, it initializes the dialog
        and connects the UI elements to their respective functions:
        - Sets the window title to "Clearings Extractor".
        - Connects the summer and winter browse buttons to the file selection dialog.
        - Connects the output directory button to the directory selection dialog.
        - Connects the run button to the image processing function.
        - Connects the clear button to the input clearing function.
        - Clears the log text edit.

        Shows the dialog and starts its event loop.
        """
        if self.first_start:
            self.first_start = False
            from .clearings_extractor_dialog import ClearingsExtractorDialog
            self.dlg = ClearingsExtractorDialog()
            self.dlg.setWindowTitle("Clearings Extractor")
            self.dlg.summerBrowseButton.clicked.connect(lambda: self.select_file(self.dlg.summerLineEdit, "Images (*.tif)"))
            self.dlg.winterBrowseButton.clicked.connect(lambda: self.select_file(self.dlg.winterLineEdit, "Images (*.tif)"))
            self.dlg.outputDirButton.clicked.connect(lambda: self.select_directory(self.dlg.outputDirLineEdit))
            self.dlg.runButton.clicked.connect(self.process_images)
            self.dlg.clearButton.clicked.connect(self.clear_inputs)
            self.dlg.logTextEdit.clear()

        self.dlg.show()
        self.dlg.exec_()

    def process_images(self):
        """
        Processes summer and winter images to extract power line clearings and saves the results.
        Steps:
        1. Checks if input files (summer image, winter image, and output directory) are provided.
        2. Opens the summer and winter images using GDAL.
        3. Validates the number of bands in the images (summer image must have at least 5 bands, winter image must have at least 3 bands).
        4. Ensures that the summer and winter images have the same pixel dimensions.
        5. Runs the clearing extraction algorithm on the images.
        6. Exports the results to a specified output directory as a TIFF file.
        7. Optionally adds the source images and the results to the QGIS map.
        Logs messages at each step to provide feedback on the process.
        Raises:
            Exception: If the clearing extraction algorithm fails.
        """
        summer_path = self.dlg.summerLineEdit.text()
        winter_path = self.dlg.winterLineEdit.text()
        output_dir = self.dlg.outputDirLineEdit.text()

        self.log_message("Checking input files...")
        if not (summer_path and winter_path and output_dir):
            self.log_message("Error: Please select summer image, winter image, and output directory")
            return

        self.log_message("Opening images...")
        summer_ds = gdal.Open(summer_path)
        winter_ds = gdal.Open(winter_path)
        
        if summer_ds is None or winter_ds is None:
            self.log_message("Error: Failed to open one or both tiff images")
            return

        self.log_message("Checking image bands...")
        if summer_ds.RasterCount < 5:
            self.log_message("Error: Summer image must have at least 5 bands")
            summer_ds = None
            winter_ds = None
            return
        if winter_ds.RasterCount < 3:
            self.log_message("Error: Winter image must have at least 3 bands")
            summer_ds = None
            winter_ds = None
            return

        self.log_message("Checking image dimensions...")
        summer_size = (summer_ds.RasterXSize, summer_ds.RasterYSize)
        winter_size = (winter_ds.RasterXSize, winter_ds.RasterYSize)
        if summer_size != winter_size:
            self.log_message("Error: Summer and winter images must have the same pixel dimensions")
            summer_ds = None
            winter_ds = None
            return

        summer_ds = None
        winter_ds = None

        self.log_message("Process begun...")

        self.log_message("Running algorithm...")
        try:
            power_line_clearings = find_clearing_algorithm(summer_path, winter_path)
        except Exception as e:
            self.log_message(f"Error: Algorithm failed: {str(e)}")
            return

        self.log_message("Algorithm finished...")

        self.log_message("Exporting results...")
        output_filename = self.dlg.outputFileLineEdit.text().strip() or "power_line_clearings.tif"
        if not output_filename.endswith(".tif"):
            output_filename += ".tif"
        temp_tiff = os.path.join(output_dir, output_filename)

        self.log_message(f"Results will be saved to {temp_tiff}")
        existing_layer = QgsProject.instance().mapLayersByName("power_line_clearings")
        if existing_layer:
            QgsProject.instance().removeMapLayer(existing_layer[0].id())
            QCoreApplication.processEvents() 

        if os.path.exists(temp_tiff):
            try:
                os.remove(temp_tiff)
            except PermissionError:
                self.log_message(f"Error: Could not delete {temp_tiff}. File may be locked by another process.")
                return

        driver = gdal.GetDriverByName("GTiff")
        out_ds = driver.Create(temp_tiff, power_line_clearings.shape[1], power_line_clearings.shape[0], 4, gdal.GDT_Byte)
        if out_ds is None:
            self.log_message(f"Error: Failed to create {temp_tiff}. Check permissions or disk space.")
            return
        
        for i in range(4):
            out_ds.GetRasterBand(i + 1).WriteArray(power_line_clearings[:, :, i])
        
        src_ds = gdal.Open(summer_path)
        out_ds.SetGeoTransform(src_ds.GetGeoTransform())
        out_ds.SetProjection(src_ds.GetProjection())
        out_ds.FlushCache()
        out_ds = None
        src_ds = None

        self.log_message("Saving completed...")
        
        if self.dlg.addImagesCheckBox.isChecked():
            self.log_message("Adding source images on the map...")
            winter_layer = QgsRasterLayer(winter_path, "winter_image")
            summer_layer = QgsRasterLayer(summer_path, "summer_image")
            if summer_layer.isValid() and winter_layer.isValid():
                QgsProject.instance().addMapLayer(winter_layer)
                QgsProject.instance().addMapLayer(summer_layer)
            else:
                self.log_message("Error: Failed to load one or both source images")
                
        self.log_message("Adding results on the map...")
        clearings_layer = QgsRasterLayer(temp_tiff, "power_line_clearings")
        if not clearings_layer.isValid():
            self.log_message("Error: Failed to load the clearings layer")
            return
        QgsProject.instance().addMapLayer(clearings_layer)

        self.log_message("Process completed")
        self.log_message(f"Success: Power line clearings extracted and saved to {temp_tiff}")
        
    def clear_inputs(self):
        """
        Clears the input fields in the dialog.

        This method clears the text in the summerLineEdit, winterLineEdit, 
        outputDirLineEdit, and logTextEdit fields of the dialog. It also logs 
        a message indicating that the inputs have been cleared and prompts 
        the user to click Run to process.
        """
        self.dlg.summerLineEdit.clear()
        self.dlg.winterLineEdit.clear()
        self.dlg.outputDirLineEdit.clear()
        self.dlg.logTextEdit.clear()
        self.log_message("Inputs cleared. Click Run to process")
        
class ClearingsExtractorAlgorithm(QgsProcessingAlgorithm):
    """
    ClearingsExtractorAlgorithm is a QGIS Processing Algorithm that extracts clearings from a pair of summer and winter images.
    Attributes:
        SUMMER_IMAGE (str): Parameter name for the summer image raster layer.
        WINTER_IMAGE (str): Parameter name for the winter image raster layer.
        OUTPUT_DIR (str): Parameter name for the output directory.
    Methods:
        initAlgorithm(config=None):
            Initializes the algorithm with the required parameters.
        processAlgorithm(parameters, context, feedback):
            Processes the input summer and winter images to extract clearings and saves the result to the specified output directory.
        name():
            Returns the unique algorithm name.
        displayName():
            Returns the display name of the algorithm.
        group():
            Returns the group name of the algorithm.
        groupId():
            Returns the unique group ID of the algorithm.
        createInstance():
            Creates and returns a new instance of the algorithm.
    """
    SUMMER_IMAGE = 'SUMMER_IMAGE'
    WINTER_IMAGE = 'WINTER_IMAGE'
    OUTPUT_DIR = 'OUTPUT_DIR'

    def initAlgorithm(self, config=None):
        """
        Initializes the algorithm with the given configuration.

        This method adds the required parameters for the algorithm:
        - A raster layer parameter for the summer image.
        - A raster layer parameter for the winter image.
        - A folder destination parameter for the output directory.

        Args:
            config (dict, optional): Configuration dictionary. Defaults to None.
        """
        self.addParameter(QgsProcessingParameterRasterLayer(self.SUMMER_IMAGE, 'Summer Image'))
        self.addParameter(QgsProcessingParameterRasterLayer(self.WINTER_IMAGE, 'Winter Image'))
        self.addParameter(QgsProcessingParameterFolderDestination(self.OUTPUT_DIR, 'Output Directory'))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Processes the algorithm to detect power line clearings from summer and winter images.
        Parameters:
        - parameters: dict
            Dictionary of parameters passed to the algorithm.
        - context: QgsProcessingContext
            Context in which the algorithm is run.
        - feedback: QgsProcessingFeedback
            Feedback object to report progress and information.
        Returns:
        - dict
            Dictionary containing the output file path with key 'OUTPUT'.
        The function performs the following steps:
        1. Retrieves the summer and winter raster layers and output directory from parameters.
        2. Checks if the images have the required number of bands and matching dimensions.
        3. Runs the clearing detection algorithm.
        4. Saves the resulting clearings to a GeoTIFF file.
        5. Adds the resulting layer to the QGIS project.
        Raises:
        - Exception: If the clearing detection algorithm fails.
        """
        summer_layer = self.parameterAsRasterLayer(parameters, self.SUMMER_IMAGE, context)
        winter_layer = self.parameterAsRasterLayer(parameters, self.WINTER_IMAGE, context)
        output_dir = self.parameterAsString(parameters, self.OUTPUT_DIR, context)

        summer_path = summer_layer.source()
        winter_path = winter_layer.source()

        feedback.pushInfo(f"Processing pair: {os.path.basename(summer_path)} (summer image) and {os.path.basename(winter_path)} (winter image)")

        summer_ds = gdal.Open(summer_path)
        winter_ds = gdal.Open(winter_path)
        if summer_ds is None or winter_ds is None:
            feedback.pushInfo(f'[ERROR] Failed to open files')
            return {}
        feedback.pushInfo(f"Checking image bands...")
        if summer_ds.RasterCount < 5:
            feedback.pushInfo(f'[ERROR] Summer image must have at least 5 bands')
            return {}
        if winter_ds.RasterCount < 3:
            feedback.pushInfo(f'[ERROR] Winter image must have at least 3 bands')
            return {}
        feedback.pushInfo(f"Checking image dimensions...")
        if (summer_ds.RasterXSize, summer_ds.RasterYSize) != (winter_ds.RasterXSize, winter_ds.RasterYSize):
            feedback.pushInfo(f'[ERROR] Dimension mismatch between images')
            return {}
        summer_ds = None
        winter_ds = None

        feedback.pushInfo(f'Running algorithm...')
        try:
            power_line_clearings = find_clearing_algorithm(summer_path, winter_path)
        except Exception as e:
            feedback.pushInfo(f'[ERROR] Algorithm failed: {str(e)}')
            return {}
        feedback.pushInfo(f'Algorithm finished...')
        
        output_filename = f"{os.path.splitext(os.path.basename(summer_path))[0]}_clearings.tif"
        temp_tiff = os.path.join(output_dir, output_filename)
        feedback.pushInfo(f'Results will be saved to {temp_tiff}')

        if os.path.exists(temp_tiff):
            try:
                os.remove(temp_tiff)
                feedback.pushInfo(f'Removed existing file: {temp_tiff}')
            except PermissionError:
                feedback.pushInfo(f'[ERROR] Could not delete {temp_tiff}. File may be locked.')
                return {}

        feedback.pushInfo(f'Exporting results...')
        driver = gdal.GetDriverByName("GTiff")
        out_ds = driver.Create(temp_tiff, power_line_clearings.shape[1], power_line_clearings.shape[0], 4, gdal.GDT_Byte)
        if out_ds is None:
            feedback.pushInfo(f'[ERROR] Failed to create {temp_tiff}')
            return {}
        
        for i in range(4):
            out_ds.GetRasterBand(i + 1).WriteArray(power_line_clearings[:, :, i])
        
        src_ds = gdal.Open(summer_path)
        out_ds.SetGeoTransform(src_ds.GetGeoTransform())
        out_ds.SetProjection(src_ds.GetProjection())
        out_ds.FlushCache()
        out_ds = None
        src_ds = None

        feedback.pushInfo(f'[SUCCESS] Saved to {temp_tiff}')
    
        layer_name = f"clearings_{os.path.splitext(os.path.basename(summer_path))[0]}"
        clearings_layer = QgsRasterLayer(temp_tiff, layer_name)
        if clearings_layer.isValid():
            existing_layer = QgsProject.instance().mapLayersByName(layer_name)
            if existing_layer:
                QgsProject.instance().removeMapLayer(existing_layer[0].id())
                feedback.pushInfo(f'Removed existing layer: {layer_name}')
            QgsProject.instance().addMapLayer(clearings_layer)
            feedback.pushInfo(f'[SUCCESS] Data loaded to map as layer: {layer_name}')
        else:
            feedback.pushInfo(f'[ERROR] Failed to load layer from {temp_tiff}')
            return {'OUTPUT': temp_tiff}

        feedback.pushInfo(f'[SUCCESS] Algorithm completed')
        return {'OUTPUT': temp_tiff}

    def name(self):
        return 'clearings_extractor'

    def displayName(self):
        return 'Extract Clearings'

    def group(self):
        return 'Clearings Extractor'

    def groupId(self):
        return 'clearings_tools'

    def createInstance(self):
        return ClearingsExtractorAlgorithm()
    
    def shortHelpString(self):
        return """
The plugin extracts forest clearings under power lines on Sentinel-2 satellite images. Before applying the algorithm, the images are pre-processed, including normalization and contrast reduction. The plugin uses the previously trained Logistic Regression to create a classification map. From the resulting map, a binary mask of the class of low vegetation, or "grassland", is extracted. The mask is then used to find lines using the Canny Boundary Detector and the Hough Probabilistic Transform. Selected lines refer to forest clearings boundaries in raster format.

Steps:
1. Select summer and winter Sentinel-2 images in .tif format. Summer image must have 5 channels in the next order: Blue (B2), Green (B3), Red (B4), Near Infrared (B8) and Shortwave Infrared (B11), and winter image must have 3 channels in the next order: Blue (B2), Green (B3) and Red (B4). Both images must have the same width and height in pixels.
2. Choose output directory for result.
3. Click Run to process.
        """

    
class IterateClearingsExtractor(QgsProcessingAlgorithm):
    """
    IterateClearingsExtractor is a QGIS Processing Algorithm that processes pairs of summer and winter Sentinel-2 images at once to extract forest clearings under power lines.
    Attributes:
        SUMMER_DIR (str): Parameter name for the summer images directory.
        WINTER_DIR (str): Parameter name for the winter images directory.
        OUTPUT_DIR (str): Parameter name for the output directory.
    Methods:
        initAlgorithm(config=None):
            Initializes the algorithm with the required parameters.
        processAlgorithm(parameters, context, feedback):
            Processes the algorithm by iterating through summer images, matching them with corresponding winter images, and saving the results.
        name():
            Returns the algorithm name.
        displayName():
            Returns the display name of the algorithm.
        group():
            Returns the group name of the algorithm.
        groupId():
            Returns the group ID of the algorithm.
        createInstance():
            Creates a new instance of the algorithm.
        shortHelpString():
            Returns a short help string describing the algorithm and its requirements.
    """
    SUMMER_DIR = 'SUMMER_DIR'
    WINTER_DIR = 'WINTER_DIR'
    OUTPUT_DIR = 'OUTPUT_DIR'

    def initAlgorithm(self, config=None):
        """
        Initializes the algorithm with the given configuration.

        This method adds three parameters to the algorithm:
        1. SUMMER_DIR: A string parameter representing the directory of summer images.
        2. WINTER_DIR: A string parameter representing the directory of winter images.
        3. OUTPUT_DIR: A folder destination parameter representing the output directory.

        Args:
            config (dict, optional): Configuration dictionary. Defaults to None.
        """
        self.addParameter(QgsProcessingParameterString(self.SUMMER_DIR, 'Summer Images Directory'))
        self.addParameter(QgsProcessingParameterString(self.WINTER_DIR, 'Winter Images Directory'))
        self.addParameter(QgsProcessingParameterFolderDestination(self.OUTPUT_DIR, 'Output Directory'))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Processes the algorithm to extract clearings from summer and winter images.

        Parameters:
        parameters (dict): Dictionary of parameters passed to the algorithm.
        context (QgsProcessingContext): Context in which the algorithm is run.
        feedback (QgsProcessingFeedback): Feedback object to report progress and information.

        Returns:
        dict: A dictionary containing the output paths of the processed files.

        The function performs the following steps:
        1. Retrieves the directories for summer images, winter images, and output from the parameters.
        2. Lists all summer image files in the summer directory.
        3. For each summer image file, checks if a corresponding winter image file exists in the winter directory.
        4. If both summer and winter image files are valid, runs the "clearings_extractor:clearings_extractor" processing algorithm.
        5. Collects the output paths of successfully processed files.
        6. Returns a dictionary containing the list of output paths.
        """
        summer_dir = self.parameterAsString(parameters, self.SUMMER_DIR, context)
        winter_dir = self.parameterAsString(parameters, self.WINTER_DIR, context)
        output_dir = self.parameterAsString(parameters, self.OUTPUT_DIR, context)

        summer_files = [f for f in os.listdir(summer_dir) if f.endswith('.tif')]
        feedback.pushInfo(f"Found {len(summer_files)} summer images")

        processed_files = []
        for summer_file in summer_files:
            winter_file = summer_file
            winter_path = os.path.join(winter_dir, winter_file)

            if os.path.exists(winter_path):
                summer_path = os.path.join(summer_dir, summer_file)
                feedback.pushInfo(f"Processing pair: {summer_file} (summer image) and {winter_file} (winter image)")

                summer_layer = QgsRasterLayer(summer_path, "summer")
                winter_layer = QgsRasterLayer(winter_path, "winter")
                if not summer_layer.isValid() or not winter_layer.isValid():
                    feedback.pushInfo(f'[ERROR] Failed to load {summer_file} or {winter_file}')
                    continue

                alg_params = {
                    'SUMMER_IMAGE': summer_layer,
                    'WINTER_IMAGE': winter_layer,
                    'OUTPUT_DIR': output_dir
                }
                result = processing.run("clearings_extractor:clearings_extractor", alg_params, context=context, feedback=feedback)

                if 'OUTPUT' in result:
                    output_path = result['OUTPUT']
                    processed_files.append(output_path)
                    feedback.pushInfo(f'[SUCCESS] Completed: {output_path}')
                else:
                    feedback.pushInfo(f'[ERROR] Failed to process {summer_file}')

        feedback.pushInfo(f'[SUCCESS] Algorithm completed')
        return {'OUTPUT': processed_files}

    def name(self):
        return 'iterate_clearings_extractor'

    def displayName(self):
        return 'Iterate Clearings Extractor'

    def group(self):
        return 'Clearings Extractor Tools'

    def groupId(self):
        return 'clearings_tools'

    def createInstance(self):
        return IterateClearingsExtractor()
    
    def shortHelpString(self):
        return """
The plugin extracts forest clearings under power lines on Sentinel-2 satellite images. Before applying the algorithm, the images are pre-processed, including normalization and contrast reduction. The plugin uses the previously trained Logistic Regression to create a classification map. From the resulting map, a binary mask of the class of low vegetation, or "grassland", is extracted. The mask is then used to find lines using the Canny Boundary Detector and the Hough Probabilistic Transform. Selected lines refer to forest clearings boundaries in raster format.

The algorithm receives two directories as input - one with summer images and one with winter images. The filenames of the images for the same area must match for the algorithm to successfully find the winter image that corresponds to the summer image for a given area. The algorithm processes each pair of images iteratively until all pairs in the two directories have been processed.

Steps:
1. Select summer and winter Sentinel-2 images in .tif format. Summer image must have 5 channels in the next order: Blue (B2), Green (B3), Red (B4), Near Infrared (B8) and Shortwave Infrared (B11), and winter image must have 3 channels in the next order: Blue (B2), Green (B3) and Red (B4). Both images must have the same width and height in pixels.
2. Choose output directory for result.
3. Click Run to process.
        """

class ClearingsExtractorProvider(QgsProcessingProvider):
    """
    ClearingsExtractorProvider is a custom QgsProcessingProvider that adds
    algorithms for extracting clearings.

    Methods
    -------
    loadAlgorithms(*args, **kwargs)
        Adds the ClearingsExtractorAlgorithm and IterateClearingsExtractor algorithms to the provider.

    id(*args, **kwargs)
        Returns the unique identifier for this provider.

    name(*args, **kwargs)
        Returns the name of this provider.

    longName(*args, **kwargs)
        Returns the long name of this provider, which is the same as the name.
    """
    def loadAlgorithms(self, *args, **kwargs):
        self.addAlgorithm(ClearingsExtractorAlgorithm())
        self.addAlgorithm(IterateClearingsExtractor())

    def id(self, *args, **kwargs):
        return 'clearings_extractor'

    def name(self, *args, **kwargs):
        return 'Clearings Extractor'

    def longName(self, *args, **kwargs):
        return self.name()